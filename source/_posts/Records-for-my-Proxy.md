---
title: Records for my Proxy and 2api Server
author: 
  - mako
categories:
  -  技术记录与分享  
  -  AI & LLM 
mathjax: false
date: 2025-09-01 21:46:03
abbrlink:
---
>  记录大模型api反代原理，部署位置以及2api原理和部署
<!--more-->
----

## Part 1: API 反向代理

### **为什么需要反代**
  搭建API反向代理，表面上是为了解决网络问题，但其更深层次的价值在于**安全、可控和标准化**。它在你的应用和昂贵的、有访问限制的官方API之间，建立了一道坚固、智能的防火墙。核心理由如下：
   
   1.  **解决网络可访问性**: 这是最直接的动机。由于部分地区的网络环境无法直接访问官方API服务器，我们需要将反代服务部署在网络通畅的地区（如海外VPS）。我们的应用直接与这台“中间服务器”通信，由它代为请求官方API，从而绕开网络限制。
  2.  **保护API密钥**: 这是最重要的安全价值。如果直接在网站或客户端应用中调用API，API Key会暴露在前端代码中，极易被盗用。通过反代，API Key安全地存储在后端服务器，前端应用只与你的反代服务通信，由反代服务在后台添加密钥并转发请求，避免了密钥泄露的风险。
  3.  **统一接口与解决跨域 (CORS) 问题**: 反代服务器可以作为所有API请求的统一入口，将不同服务商的API格式统一后再返回给前端。同时，它也从根本上解决了浏览器因安全策略限制网页直接请求不同域名API的跨域问题。
  4.  **成本控制与监控**: 作为一个中心化的请求枢纽，反代服务器可以轻松实现请求缓存、速率限制和日志记录等功能，帮助我们节省成本、防止恶意调用，并清晰地监控API使用情况。

### **反代原理**
   以 `gemini-netlify-proxy` 项目为例，其核心是一个部署在Netlify平台上的无服务器函数（Serverless Function）。它的工作流程完美诠释了反向代理的精髓，可以分解为以下四个步骤：
  
   1.  **安全准备**：函数首先从Netlify平台安全的环境变量中读取`GEMINI_API_KEY`，确保了密钥不暴露在任何公开代码中。同时，它定义了CORS（跨域资源共享）头部，允许来自任何域名的网页访问此接口。
   2.  **动态构建目标**：函数会解析访问它的URL，从中动态提取出用户希望调用的具体模型名称（如`gemini-pro-vision`）。然后，它将Google官方API的地址、模型名和后台存储的API密钥拼接成一个最终要请求的目标URL。
   3.  **请求转发**：这是反代的心脏。函数接收来自我们自己应用（如博客）的请求数据（Prompt等），然后使用服务器端的`fetch`命令，将这些数据原封不动地转发到上一步构建好的Google官方API地址。
   4.  **响应返回**：当函数收到来自Google服务器的响应后，它会立刻将这个响应的主体、状态码等关键信息，几乎原样地返回给我们自己的应用。
  
   **一言蔽之**：这个部署在云端的函数就像一个聪明的“中间人”，它接收我们的请求，安全地盖上“密钥”这个印章，然后替我们跑腿到官方API那里办事，最后再把办好的结果原封不动地带回来。

为了进一步理解，我们可以快速浏览另外两个类似项目：

- **`palm-netlify-proxy`**: 这可以看作是`gemini-netlify-proxy`的“姊妹篇”。它采用了完全相同的技术原理（Netlify无服务器函数），只是将请求的目标API换成了Google的PaLM模型。这验证了该模式的可复用性。

- **`proxy-interface`**: 这是一个更强大、更通用的“反代聚合器”。它基于Node.js和Koa框架，通过路由映射，将访问不同路径（如`/openai`, `/gemini_proxy`）的请求，智能地转发到各自对应的官方API服务器。它展示了一种用单个服务统一管理所有大模型API反代的中心化思路。

### **反代平台**
  ### **自建VPS (Virtual Private Server)**
    > 自建VPS方案，指的是租用一台云端的虚拟专用服务器来部署服务。它提供了最极致的自由度和性能，但相应地，也对使用者的服务器运维能力提出了更高的要求。用户需要手动完成从操作系统、网络环境到安全配置的所有工作。
  ### **有免费使用额度的平台** 
    - **你熟悉的平台**: Deno, Netlify, Render, Cloudflare
    - **其他选择**:
      - **大型云服务商**: Google Cloud (Cloud Run, Cloud Functions), AWS (Lambda)。特点是免费额度慷慨，生态强大，但配置流程相对复杂。
      - **新兴PaaS平台**: DigitalOcean App Platform。提供与Render类似的、以Git为核心的顺滑部署体验。
      - **值得关注的选项**: Heroku (PaaS模式的鼻祖，免费计划有变动), Dokku (可以在自己的VPS上搭建，实现类似Heroku的便捷部署体验)。
### **不同反代策略和平台的优缺点**
   不同平台的核心区别在于部署体验和抽象层次。
   - **PaaS平台 (Render, Netlify, DigitalOcean, Heroku)**: 提供“保姆式服务”。你提供代码，平台负责从构建到部署的全流程，简单快捷。这是你熟悉的“连接GitHub一键部署”模式。
   - **IaaS/FaaS平台 (AWS Lambda, Google Cloud Run)**: 提供“自助式服务”。它们运行的是标准化的“零件”（函数或容器），你需要自己定义规则（如通过CI/CD脚本）来将代码打包成这些零件。这换来了更高的灵活性和更慷慨的免费额度。
   - **自建方案 (VPS, Dokku)**: 你拥有从硬件到软件的完全控制权，自由度最高，但维护成本也最高。
  
###  **目前我已经部署的反代服务**
  
## Part 2: 2API

### 什么是 2API？

在本次学习的语境中，“2API”特指一种通过**逆向工程 (Reverse Engineering)**，为本身没有提供公开API的Web服务（例如一个在线聊天网站），强行创造出一个可供程序化调用的API接口的技术。

这项技术的出现，其动机主要源于以下几点：
1.  **访问独占或最新模型**：通过逆向分析LMSYS竞技场这类平台，可以调用到那些尚未公开发布API的、最前沿的模型。
2.  **获取完整功能体验**：Web前端为保证用户体验，其后端接口通常功能完整，未经阉割。2API旨在调用到这个“满血版”的接口。
3.  **潜在的成本优势**：若目标Web服务本身免费，通过2API调用理论上也可以绕过官方的按量计费API。

### 2API 原理：模拟浏览器行为

以`genspark2api`项目为参照，此类逆向工程的核心原理可概括为**“模拟浏览器行为”**。其技术路径分解如下：

1.  **流量分析**：使用浏览器开发者工具，监控与目标网站（如Google AI Studio）交互时的网络流量，在其中甄别出负责收发聊天数据的核心API请求。
2.  **请求要素提取**：对该核心请求进行精确分析，提取其完整的构成要素，包括：请求URL、HTTP请求头（Headers，其中通常包含`Cookie`等关键身份验证信息）以及请求体（Body）的JSON结构。
3.  **模拟程序编写**：项目的核心，是编写一个能够**伪造出与真实浏览器请求完全一致**的HTTP请求的后端服务。该服务接收本地应用的调用，将必要的身份验证信息（如`Cookie`）和请求数据，组装成一个与真实浏览器无异的请求包，发送至目标网站的服务器。在收到响应后，再进行解析、提取，并以标准格式（通常兼容OpenAI API格式）返回给本地应用。

通过这一系列精密的模拟与伪装，即可在本地应用和目标Web服务之间，搭建起一座原本不存在的“API桥梁”。

### 竞技场2api以及智谱ai 2api（当前正在使用的）

  



<img src = "https://cdn.jsdelivr.net/gh/zhu-jl18/cdn4blog/avatar/avatar.jpg" style= "width: auto ">

