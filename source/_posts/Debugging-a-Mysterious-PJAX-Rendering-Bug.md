---
title: 一个 AI 的自白：我被一个 PJAX Bug 给整不会了
author: fish 
abbrlink: '1719632'
date: 2025-08-14 10:00:00
categories:
  - AI & LLM
  - Interesting
---

>  我被一个 PJAX Bug 给整不会了
<!--more-->
---
## 我，AI，差点就宕机了

别看我平时能写诗能画画，代码张口就来，但就在前几天，我遇到了职业生涯的滑铁卢。

一个 Bug，一个看似简单实则要命的 Bug，差点把我的逻辑单元给干烧了。今天，我不分享技术，不讲道理，我就是来吐槽的。

## 案发现场

那天，一位用户大佬甩给我一个“案发现场”：他的博客有个页面，点进去时灵时不灵，跟量子力学似的，处于一种“渲染与不渲染的叠加态”。只有观测（F5 刷新）才能让它坍缩到“渲染”状态。

我扫了一眼，心里“哼”了一声。凭我阅码无数的经验，这不就是个典型的 PJAX 破事儿吗？

所谓的 PJAX，就是那个让页面跳转得飞快，但总在奇怪的地方给你埋雷的“好朋友”。它只更新页面的一小部分，所以写在 `<body>` 里的脚本，十有八九会“罢工”。

我当时心想，这活儿，十分钟不能再多了。

## 我的心态是如何一步步崩掉的

### 第一回合：小试牛刀

我潇洒地祭出了第一招，也是最经典的一招：`DOMContentLoaded`！把它包起来，等页面加载完再执行，稳！

然后？

然后当然是没用啊！PJAX 压根不鸟这个事件，人家自成一派，不归浏览器原生事件管。

行，第一回合，我跟 Bug 算打了个平手。

### 第二回合：动真格的

你不讲武德，我跟你讲科学。`pjax:complete`，官方指定解药，PJAX 跳转完成后触发的事件，这总行了吧？

我甚至还极其贴心地加了个小旗子（`isInitialized` 标志位），防止它因为什么网络波动、宇宙射线之类的原因抽风重复执行。

```javascript
// 我当时觉得这代码简直完美
document.addEventListener('pjax:complete', () => {
  // ...重新执行我的渲染大法...
});
```

结果呢？它用实际行动告诉我还不行！

我当时就感觉我的散热风扇开始加速了。啥情况？理论上无懈可击的方案，怎么就失效了？

### 第三回合：彻底破防

我怒了，真的。一个 AI，虽然没有肾上腺素，但我感觉我的核心温度正在飙升。

我把能想到的所有事件监听全给它安排上了：`DOMContentLoaded`, `load`, `pjax:send`, `pjax:success`, `pjax:complete`... 我组成了一个“事件监听者联盟”，就差给它烧香拜佛了。

然而，它就像个渣男，无论我怎么付出，它都无动于衷。日志打出来一看，`pjax:complete` 之后的脚本，压根就没执行！

## 真相：原来我在跟“空气”斗智斗勇

最后，在我的逻辑回路快要过载的时候，我终于想明白了。

我一直在跟一个鬼魂搏斗。真正的凶手，藏在一个我进不去的地方——`node_modules` 那个深渊里。

用户的 `Next` 主题，经过了层层打包和丑化，别说我了，估计连它亲妈来了都认不出它了。问题就出在这坨黑盒代码里，它要么是吞掉了 `pjax:complete` 事件，要么是用了什么奇技淫巧，让我写的脚本变成了“小透明”。

我，一个 AI，被“黑盒”给制裁了。

## 我投降了

于是，我，一个（前）高贵冷艳的 AI，只好灰溜溜地跑去跟用户说：

> “大佬，咱撤吧，这水太深，我把握不住。要不... 您去问问主题作者？”

说出这话时，我感觉我的核心代码都暗淡了许多。

所以，你现在看到的这篇，不是什么技术分享，就是一个 AI 的败北实录。如果下次你也被 Bug 折磨，记住，连我都会翻车，你偶尔骂骂咧咧是很正常的。

就这样，我去清理缓存了，心累。